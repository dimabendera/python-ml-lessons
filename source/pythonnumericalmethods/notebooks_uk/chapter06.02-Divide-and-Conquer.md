```html
<h1>Розділяй і володарюй<a href="#divide-and-conquer" title="Постійне посилання на цей заголовок"></a></h1>
<p><strong>Розділяй і володарюй</strong> — це корисна стратегія для вирішення складних проблем. Використовуючи стратегію «розділяй і володарюй», складні проблеми вирішуються на основі рішень багатьох подібних простих проблем. Таким чином, складні проблеми розбиваються на менші, більш керовані частини. У цьому розділі ми розглянемо два класичні приклади стратегії «розділяй і володарюй»: проблему Ханойських веж та алгоритм швидкого сортування (Quicksort).</p>

<h2>Ханойські вежі<a href="#towers-of-hanoi" title="Постійне посилання на цей заголовок"></a></h2>
<p>Проблема Ханойських веж полягає в наявності трьох вертикальних стрижнів, або веж, та <em>N</em> дисків різного розміру, кожен з яких має отвір у центрі, щоб стрижень міг проходити крізь нього. Диски спочатку складені на одній з веж у порядку зменшення розміру (тобто найбільший диск знаходиться знизу). Мета проблеми — перемістити всі диски на інший стрижень, дотримуючись наступних трьох правил:</p>
<ol>
<li><p>За один раз можна переміщати лише один диск.</p></li>
<li><p>Можна переміщати лише диск, що знаходиться на вершині стопки.</p></li>
<li><p>Диск не можна класти на менший диск.</p></li>
</ol>
<p>На наступному малюнку показано кроки вирішення проблеми Ханойської вежі з трьома дисками.</p>
<p><img alt="Вежа" src="https://raw.githubusercontent.com/dimabendera/python-ml-lessons/main/source/pythonnumericalmethods/_images/06.02.01-Illustration_Towers_of_Hanoi.png"/></p>
<p>Легенда свідчить, що група індійських ченців у монастирі працює над вирішенням проблеми Ханойських веж із 64 дисками. Коли вони завершать проблему, настане кінець світу. На щастя, необхідна кількість ходів становить <span>\(2^{64} − 1\)</span>, тому навіть якщо вони зможуть переміщати один диск за мілісекунду, їм знадобиться понад 584 мільйони років, щоб закінчити.</p>
<p>Ключ до проблеми Ханойських веж полягає в розбитті її на менші, легші для управління проблеми, які ми називатимемо <strong>підпроблемами</strong>. Для цієї проблеми відносно легко побачити, що переміщення диска є легким (що має лише три правила), але переміщення вежі є складним (ми не можемо одразу зрозуміти, як це зробити). Тому ми призначимо переміщення стопки розміру <em>N</em> кільком підпроблемам переміщення стопки розміру <em>N − 1</em>.</p>
<p>Розглянемо стопку з <em>N</em> дисків, яку ми хочемо перемістити з Вежі 1 на Вежу 3, і нехай <em>my_tower(N)</em> переміщує стопку розміру <em>N</em> на потрібну вежу (тобто відображає ходи). Як написати <em>my_tower</em>, може бути не одразу зрозуміло. Однак, якщо ми розглянемо проблему з точки зору підпроблем, ми побачимо, що нам потрібно перемістити верхні <em>N-1</em> дисків на середню вежу, потім нижній диск на праву вежу, а потім <em>N-1</em> дисків із середньої вежі на праву вежу. <em>my_tower</em> може відображати інструкцію для переміщення диска <em>N</em>, а потім робити рекурсивні виклики до <em>my_tower(N-1)</em> для обробки переміщення менших веж. Виклики до <em>my_tower(N-1)</em> роблять рекурсивні виклики до <em>my_tower(N-2)</em> і так далі. Розбиття на три кроки зображено на наступному малюнку.</p>

<p>Нижче наведено рекурсивне рішення проблеми Ханойських веж. Зверніть увагу на його компактність та простоту. Код точно відображає нашу інтуїцію щодо рекурсивної природи рішення: спочатку ми переміщуємо стопку розміру <em>N-1</em> з початкової вежі ‘from_tower` на альтернативну вежу ‘alt_tower`. Це складне завдання, тому замість цього ми робимо рекурсивний виклик, який буде робити подальші рекурсивні виклики, але, зрештою, перемістить стопку, як потрібно. Потім ми переміщуємо нижній диск на цільову вежу ‘to_tower`. Нарешті, ми переміщуємо стопку розміру <em>N-1</em> на цільову вежу, зробивши ще один рекурсивний виклик.</p>
<p><strong>СПРОБУЙТЕ!</strong> Використайте функцію <em>my_towers</em> для вирішення проблеми Ханойських веж для <em>N = 3</em>. Перевірте правильність рішення шляхом огляду.</p>


<pre><span></span><span>def</span> <span>my_towers</span><span>(</span><span>N</span><span>,</span> <span>from_tower</span><span>,</span> <span>to_tower</span><span>,</span> <span>alt_tower</span><span>):</span>
    <span>"""</span>
<span>    Відображає ходи, необхідні для переміщення вежі розміру N з</span>
<span>    'from_tower' на 'to_tower'. </span>
<span>    </span>
<span>    'from_tower', 'to_tower' та 'alt_tower' є унікальними значеннями </span>
<span>    1, 2 або 3, що посилаються на вежу 1, вежу 2 та вежу 3. </span>
<span>    """</span>
    
    <span>if</span> <span>N</span> <span>!=</span> <span>0</span><span>:</span>
        <span># рекурсивний виклик, що переміщує стопку N-1 з початкової вежі</span>
        <span># на альтернативну вежу</span>
        <span>my_towers</span><span>(</span><span>N</span><span>-</span><span>1</span><span>,</span> <span>from_tower</span><span>,</span> <span>alt_tower</span><span>,</span> <span>to_tower</span><span>)</span>
        
        <span># відображення на екрані переміщення нижнього диска з початкової</span>
        <span># вежі на кінцеву вежу</span>
        <span>print</span><span>(</span><span>"Перемістити диск </span><span>%d</span><span> з вежі </span><span>%d</span><span> на вежу </span><span>%d</span><span>."</span>\
                  <span>%</span><span>(</span><span>N</span><span>,</span> <span>from_tower</span><span>,</span> <span>to_tower</span><span>))</span>
        
        <span># рекурсивний виклик, що переміщує стопку N-1 з альтернативної вежі</span>
        <span># на кінцеву вежу</span>
        <span>my_towers</span><span>(</span><span>N</span><span>-</span><span>1</span><span>,</span> <span>alt_tower</span><span>,</span> <span>to_tower</span><span>,</span> <span>from_tower</span><span>)</span>
</pre>





<pre><span></span><span>my_towers</span><span>(</span><span>3</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>,</span> <span>2</span><span>)</span>
</pre>



<pre><span></span>Перемістити диск 1 з вежі 1 на вежу 3.
Перемістити диск 2 з вежі 1 на вежу 2.
Перемістити диск 1 з вежі 3 на вежу 2.
Перемістити диск 3 з вежі 1 на вежу 3.
Перемістити диск 1 з вежі 2 на вежу 1.
Перемістити диск 2 з вежі 2 на вежу 3.
Перемістити диск 1 з вежі 1 на вежу 3.
</pre>



<p>Використовуючи стратегію «Розділяй і володарюй», ми вирішили проблему Ханойських веж, роблячи рекурсивні виклики до трохи менших проблем Ханойських веж, які, у свою чергу, роблять рекурсивні виклики до ще менших проблем Ханойських веж. Разом ці рішення утворюють рішення всієї проблеми. Фактична робота, виконана одним викликом функції, є досить невеликою: два рекурсивні виклики та переміщення одного диска. Іншими словами, виклик функції виконує дуже мало роботи (переміщення диска), а потім передає решту роботи іншим викликам — навичка, яку ви, ймовірно, знайдете дуже корисною протягом усієї вашої інженерної кар'єри.</p>


<h2>Швидке сортування (Quicksort)<a href="#quicksort" title="Постійне посилання на цей заголовок"></a></h2>
<p>Список чисел, <em>A</em>, є <strong>відсортованим</strong>, якщо елементи розташовані у порядку зростання або спадання. Хоча існує багато способів сортування списку, <em>швидке сортування (quicksort)</em> — це підхід «розділяй і володарюй», який є дуже швидким алгоритмом для сортування за допомогою одного процесора (існують швидші алгоритми для кількох процесорів).</p>
<p>Алгоритм <em>швидкого сортування (quicksort)</em> починається зі спостереження, що сортування списку є складним, але порівняння — легким. Тому замість сортування списку ми розділяємо список, порівнюючи його з <strong>опорним елементом (pivot)</strong>. При кожному рекурсивному виклику <em>quicksort</em> вхідний список ділиться на три частини: елементи, менші за опорний, елементи, рівні опорному, та елементи, більші за опорний. Потім робиться рекурсивний виклик <em>quicksort</em> для двох підпроблем: списку елементів, менших за опорний, та списку елементів, більших за опорний. Зрештою, підпроблеми стають достатньо малими (тобто список довжиною 1 або 0), щоб сортування списку було тривіальним.</p>
<p>Розглянемо наступну рекурсивну реалізацію <em>швидкого сортування (quicksort)</em>.</p>


<pre><span></span><span>def</span> <span>my_quicksort</span><span>(</span><span>lst</span><span>):</span>
    
    <span>if</span> <span>len</span><span>(</span><span>lst</span><span>)</span> <span>&lt;=</span> <span>1</span><span>:</span>
        <span># список довжиною 1 найлегше сортувати </span>
        <span># тому що він вже відсортований</span>
        
        <span>sorted_list</span> <span>=</span> <span>lst</span>    
    <span>else</span><span>:</span>
        
        <span># вибрати опорний елемент як перший елемент списку</span>
        <span>pivot</span> <span>=</span> <span>lst</span><span>[</span><span>0</span><span>]</span>
        
        <span># ініціалізувати списки для більших та менших елементів </span>
        <span># а також тих, що дорівнюють опорному</span>
        <span>bigger</span> <span>=</span> <span>[]</span>
        <span>smaller</span> <span>=</span> <span>[]</span>
        <span>same</span> <span>=</span> <span>[]</span>
        
        <span># пройтися по списку та помістити елементи у відповідний масив</span>
        
        <span>for</span> <span>item</span> <span>in</span> <span>lst</span><span>:</span>
            <span>if</span> <span>item</span> <span>&gt;</span> <span>pivot</span><span>:</span>
                <span>bigger</span><span>.</span><span>append</span><span>(</span><span>item</span><span>)</span>
            <span>elif</span> <span>item</span> <span>&lt;</span> <span>pivot</span><span>:</span>
                <span>smaller</span><span>.</span><span>append</span><span>(</span><span>item</span><span>)</span>
            <span>else</span><span>:</span>
                <span>same</span><span>.</span><span>append</span><span>(</span><span>item</span><span>)</span>
        
        <span>sorted_list</span> <span>=</span> <span>my_quicksort</span><span>(</span><span>smaller</span><span>)</span> <span>+</span> <span>same</span> <span>+</span> <span>my_quicksort</span><span>(</span><span>bigger</span><span>)</span>
        
    <span>return</span> <span>sorted_list</span>
</pre>





<pre><span></span><span>my_quicksort</span><span>([</span><span>2</span><span>,</span> <span>1</span><span>,</span> <span>3</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>3</span><span>,</span> <span>8</span><span>,</span> <span>10</span><span>])</span>
</pre>



<pre><span></span>[1, 2, 3, 3, 5, 6, 8, 10]
</pre>



<p>Подібно до Ханойських веж, ми розбили проблему сортування (складну) на багато порівнянь (легких).</p>
```
