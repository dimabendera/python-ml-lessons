<h1>Складність та Big-O нотація<a href="#complexity-and-big-o-notation" title="Постійне посилання на цей заголовок"></a></h1>
<p><strong>Складність</strong> функції — це зв'язок між розміром вхідних даних та складністю виконання функції до завершення. Розмір вхідних даних зазвичай позначається як <span>\(n\)</span>. Однак <span>\(n\)</span> зазвичай описує щось більш відчутне, наприклад, довжину масиву. Складність проблеми можна виміряти кількома способами. Один із підходящих способів описати складність проблеми — використовувати <strong>базові операції</strong>: додавання, віднімання, множення, ділення, присвоєння та виклики функцій. Хоча кожна базова операція займає різну кількість часу, кількість базових операцій, необхідних для завершення функції, достатньо пов'язана з часом виконання, щоб бути корисною, і її набагато легше підрахувати.</p>
<p><strong>СПРОБУЙТЕ!</strong> Підрахуйте кількість базових операцій, виражених через <span>\(n\)</span>, необхідних для завершення наступної функції.</p>


<pre><span></span><span>def</span> <span>f</span><span>(</span><span>n</span><span>):</span>
    <span>out</span> <span>=</span> <span>0</span>
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>n</span><span>):</span>
        <span>for</span> <span>j</span> <span>in</span> <span>range</span><span>(</span><span>n</span><span>):</span>
            <span>out</span> <span>+=</span> <span>i</span><span>*</span><span>j</span>
            
    <span>return</span> <span>out</span>
</pre>



<p>Давайте підрахуємо кількість операцій:</p>
<p>додавання: <span>\(n^2\)</span>, віднімання: 0, множення: <span>\(n^2\)</span>, ділення: 0, присвоєння: <span>\(2n^2 +1\)</span>, виклики функцій: 0, всього: <span>\(4n^2+1\)</span>.</p>
<p>Кількість присвоєнь становить <span>\(2n^2 + n + 1\)</span>, оскільки рядок <span>\(out += i*j\)</span> обчислюється <span>\(n^2\)</span> разів, <span>\(j\)</span> присвоюється <span>\(n^2\)</span> разів, <span>\(i\)</span> присвоюється <span>\(n\)</span> разів, а рядок <span>\(out = 0\)</span> присвоюється один раз. Отже, складність функції <span>\(f\)</span> можна описати як <span>\(4n^2 + n + 1\)</span>.</p>
<p>Поширеною нотацією для складності є <strong>Big-O нотація</strong>. Big-O нотація встановлює зв'язок у зростанні кількості базових операцій відносно розміру вхідних даних, коли розмір вхідних даних стає дуже великим. Оскільки апаратне забезпечення відрізняється на кожній машині, ми не можемо точно розрахувати, скільки часу знадобиться для завершення, не оцінивши також апаратне забезпечення. Тоді цей аналіз буде дійсним лише для цієї конкретної машини. Нас насправді не цікавить, скільки часу займає певний набір вхідних даних на конкретній машині. Натомість ми проаналізуємо, як швидко зростає "час до завершення" в термінах базових операцій зі збільшенням розміру вхідних даних, оскільки цей аналіз не залежить від апаратного забезпечення. Коли <span>\(n\)</span> стає великим, домінує найвищий степінь; тому в Big-O нотацію включається лише член з найвищим степенем. Крім того, коефіцієнти не потрібні для характеристики зростання, тому коефіцієнти також відкидаються. У попередньому прикладі ми нарахували <span>\(4n^2 + n + 1\)</span> базових операцій для завершення функції. У Big-O нотації ми б сказали, що функція є <span>\(O(n^2)\)</span> (вимовляється "О від ен квадрат"). Ми говоримо, що будь-який алгоритм зі складністю <span>\(O(nc)\)</span>, де <span>\(c\)</span> є деякою константою відносно <span>\(n\)</span>, є <strong>поліноміальним за часом</strong>.</p>
<p><strong>СПРОБУЙТЕ!</strong> Визначте складність ітеративної функції Фібоначчі в Big-O нотації.</p>


<pre><span></span><span>def</span> <span>my_fib_iter</span><span>(</span><span>n</span><span>):</span>
    
    <span>out</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>1</span><span>]</span>
    
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>2</span><span>,</span> <span>n</span><span>):</span>
        <span>out</span><span>.</span><span>append</span><span>(</span><span>out</span><span>[</span><span>i</span> <span>-</span> <span>1</span><span>]</span> <span>+</span> <span>out</span><span>[</span><span>i</span> <span>-</span> <span>2</span><span>])</span>
        
    <span>return</span> <span>out</span>
</pre>



<p>Оскільки єдині рядки коду, які займають більше часу зі зростанням <span>\(n\)</span>, знаходяться в циклі for, ми можемо обмежити нашу увагу циклом for та блоком коду всередині нього. Код всередині циклу for не зростає відносно <span>\(n\)</span> (тобто є константним). Отже, кількість базових операцій становить <span>\(Cn\)</span>, де <span>\(C\)</span> — деяка константа, що представляє кількість базових операцій, які відбуваються в циклі for, і ці <span>\(C\)</span> операції виконуються <span>\(n\)</span> разів. Це дає складність <span>\(O(n)\)</span> для <span>\(my\_fib\_iter\)</span>.</p>
<p>Оцінка точної складності функції може бути складною. У таких випадках може бути достатньо вказати верхню межу або навіть наближення складності.</p>
<p><strong>СПРОБУЙТЕ!</strong> Вкажіть верхню межу складності рекурсивної реалізації Фібоначчі. Чи вважаєте ви, що це хороше наближення верхньої межі? Чи вважаєте ви, що рекурсивна функція Фібоначчі може бути поліноміальною за часом?</p>


<pre><span></span><span>def</span> <span>my_fib_rec</span><span>(</span><span>n</span><span>):</span>
    
    <span>if</span> <span>n</span> <span>&lt;</span> <span>2</span><span>:</span>
        <span>out</span> <span>=</span> <span>1</span>
    <span>else</span><span>:</span>
        <span>out</span> <span>=</span> <span>my_fib_rec</span><span>(</span><span>n</span><span>-</span><span>1</span><span>)</span> <span>+</span> <span>my_fib_rec</span><span>(</span><span>n</span><span>-</span><span>2</span><span>)</span>
        
    <span>return</span> <span>out</span>
</pre>



<p>Коли <span>\(n\)</span> стає великим, можна сказати, що переважна більшість викликів функцій робить два інші виклики функцій: одне додавання та одне присвоєння вихідному значенню. Додавання та присвоєння не зростають з <span>\(n\)</span> на кожен виклик функції, тому ми можемо ігнорувати їх у Big-O нотації. Однак кількість викликів функцій зростає приблизно на <span>\(2^n\)</span>, тому складність <span>\(my\_fib\_rec\)</span> обмежена зверху <span>\(O(2^n)\)</span>.</p>
<p>Тривають дебати щодо того, чи є <span>\(O(2^n)\)</span> хорошим наближенням для функції Фібоначчі.</p>
<p>Оскільки кількість рекурсивних викликів зростає експоненціально з <span>\(n\)</span>, рекурсивна функція Фібоначчі жодним чином не може бути поліноміальною. Тобто, для будь-якого <span>\(c\)</span> існує таке <span>\(n\)</span>, що <span>\(my\_fib\_rec\)</span> потребує більше ніж <span>\(O(n^c)\)</span> базових операцій для завершення. Будь-яка функція, яка є <span>\(O(c^n)\)</span> для деякої константи <span>\(c\)</span>, вважається <strong>експоненціальною за часом</strong>.</p>
<p><strong>СПРОБУЙТЕ!</strong> Яка складність наступної функції в Big-O нотації?</p>


<pre><span></span><span>def</span> <span>my_divide_by_two</span><span>(</span><span>n</span><span>):</span>
    
    <span>out</span> <span>=</span> <span>0</span>
    <span>while</span> <span>n</span> <span>&gt;</span> <span>1</span><span>:</span>
        <span>n</span> <span>/=</span> <span>2</span>
        <span>out</span> <span>+=</span> <span>1</span>
        
    <span>return</span> <span>out</span>
</pre>



<p>Знову ж таки, лише цикл while працює довше для більших <span>\(n\)</span>, тому ми можемо обмежити нашу увагу ним. Усередині циклу while є два присвоєння: одне ділення та одне додавання, які обидва є константними за часом відносно <span>\(n\)</span>. Отже, складність залежить лише від того, скільки разів виконується цикл while.</p>
<p>Цикл while ділить <span>\(n\)</span> навпіл на кожній ітерації, доки <span>\(n\)</span> не стане меншим за 1. Отже, кількість ітерацій, <span>\(I\)</span>, є розв'язком рівняння <span>\(\frac{n}{2^I} = 1\)</span>. Після деяких маніпуляцій це розв'язується як <span>\(I = \log n\)</span>, тому складність <span>\(my\_divide\_by\_two\)</span> становить <span>\(O(\log n)\)</span>. Не має значення, яка основа логарифма, оскільки, згадуючи правила логарифмів, усі логарифми є скалярними кратними один одному. Будь-яка функція зі складністю <span>\(O(\log n)\)</span> вважається <strong>логарифмічною за часом</strong>.</p>
