<h1>Підсумок<a href="#summary" title="Постійне посилання на цей заголовок"></a></h1>
<ol>
<li><p>Складність алгоритму — це зв'язок між розміром вхідної задачі та часом, необхідним для завершення роботи алгоритму.</p></li>
<li><p>Нотація Big-O — це стандартний метод класифікації алгоритмічної складності таким чином, що є незалежним від комп'ютера та операційної системи.</p></li>
<li><p>Алгоритми з логарифмічною складністю швидші за алгоритми з поліноміальною складністю, які швидші за алгоритми з експоненційною складністю.</p></li>
<li><p>Профайлер — це корисний інструмент для визначення того, де ваш код працює повільно, щоб ви могли покращити його продуктивність.</p></li>
</ol>


<h1>Задачі<a href="#problems" title="Постійне посилання на цей заголовок"></a></h1>
<ol>
<li><p>Як би ви визначили розмір наступних задач?</p>
<ul>
<li><p>Складання пазла.</p></li>
<li><p>Роздача роздаткового матеріалу класу.</p></li>
<li><p>Йти на заняття.</p></li>
<li><p>Пошук імені у словнику.</p></li>
</ul>
</li>
<li><p>Для задач, наведених у попередній задачі, якою, на вашу думку, є складність Big-O цих задач з точки зору визначень розміру, які ви надали?</p></li>
<li><p>Можливо, ви будете здивовані, дізнавшись, що існує алгоритм з <span>\(\log\)</span> часом для пошуку слова у словнику з <span>\(n\)</span> слів. Замість того, щоб починати з початку списку, ви переходите до середини. Якщо це слово, яке ви шукаєте, тоді ви завершили. Якщо слово йде після слова, яке ви шукаєте, тоді шукайте на півдорозі між поточним словом і кінцем. Якщо воно перед словом, яке ви шукаєте, тоді шукайте на півдорозі між першим словом і поточним словом. Продовжуйте повторювати цей процес, доки не знайдете слово. Цей алгоритм відомий як бінарний пошук, і він має <span>\(\log\)</span> час, оскільки простір пошуку зменшується вдвічі на кожній ітерації, і, отже, вимагає щонайбільше <span>\(\log_2(n)\)</span> ітерацій для пошуку слова. Отже, збільшення часу виконання є лише логарифмічним від довжини списку.</p></li>
</ol>
<p>Існує спосіб знайти слово за <span>\(O(1)\)</span> або постійний час. Це означає, що незалежно від довжини списку, це займає однакову кількість часу! Чи можете ви придумати, як це робиться? Підказка: Дослідіть хеш-функції.</p>
<ol>
<li><p>Яка складність алгоритмів, що обчислюють наступні рекурсивні співвідношення? Класифікуйте наступні алгоритми як логарифмічний час, поліноміальний час або експоненційний час відносно n, враховуючи, що реалізація є (a) рекурсивною та (b) ітеративною.</p></li>
</ol>
<p>Трибоначчі, <span>\(T(n)\)</span>:</p>

\[\begin{split}\begin{eqnarray*}
T(n) &amp;=&amp; T(n-1) + T(n-2) + T(n-3)\\
T(1) &amp;=&amp; T(2) = T(3) = 1.
\end{eqnarray*}\end{split}\]
<p>Тімміначчі, <span>\(t(n)\)</span>:</p>

\[\begin{split}\begin{eqnarray*}
t(n) &amp;=&amp; t(n/2) + t(n/4)\\
t(n) &amp;=&amp; 1\ if\ n &lt; 1.
\end{eqnarray*}\end{split}\]
<ol>
<li><p>Яка складність Big-O задачі «Ханойські вежі», наведеної в Розділі 6? Чи є ця складність верхньою межею чи вона точна?</p></li>
<li><p>Яка складність Big-O алгоритму швидкого сортування (quicksort)?</p></li>
<li><p>Запустіть наступні дві ітеративні реалізації пошуку чисел Фібоначчі в line_profiler, а також використовуючи магічну команду для отримання повторного часу виконання. Перша реалізація попередньо виділяє пам'ять для масиву, який зберігає всі числа Фібоначчі. Друга реалізація розширює список на кожній ітерації циклу for.</p></li>
</ol>


<pre><span></span><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>

<span>def</span> <span>my_fib_iter1</span><span>(</span><span>n</span><span>):</span>
    <span>out</span> <span>=</span> <span>np</span><span>.</span><span>zeros</span><span>(</span><span>n</span><span>)</span>
    
    <span>out</span><span>[:</span><span>2</span><span>]</span> <span>=</span> <span>1</span>
    
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>2</span><span>,</span> <span>n</span><span>):</span>
        <span>out</span><span>[</span><span>i</span><span>]</span> <span>=</span> <span>out</span><span>[</span><span>i</span><span>-</span><span>1</span><span>]</span> <span>+</span> <span>out</span><span>[</span><span>i</span><span>-</span><span>2</span><span>]</span>
        
    <span>return</span> <span>out</span>

<span>def</span> <span>my_fib_iter2</span><span>(</span><span>n</span><span>):</span>
    
    <span>out</span> <span>=</span> <span>[</span><span>1</span><span>,</span> <span>1</span><span>]</span>
    
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>2</span><span>,</span> <span>n</span><span>):</span>
        <span>out</span><span>.</span><span>append</span><span>(</span><span>out</span><span>[</span><span>i</span><span>-</span><span>1</span><span>]</span><span>+</span><span>out</span><span>[</span><span>i</span><span>-</span><span>2</span><span>])</span>
        
    <span>return</span> <span>np</span><span>.</span><span>array</span><span>(</span><span>out</span><span>)</span>
</pre>
