```html
<h1>Числа з рухомою комою<a href="#floating-point-numbers" title="Постійне посилання на цей заголовок"></a></h1>
<p>Кількість бітів зазвичай є фіксованою для будь-якого комп'ютера. Використання двійкового представлення дає нам недостатній діапазон і точність чисел для виконання відповідних інженерних обчислень. Щоб досягти необхідного діапазону значень з тією ж кількістю бітів, ми використовуємо числа з <strong>рухомою комою</strong>, або скорочено <strong>float</strong>. Замість того, щоб використовувати кожен біт як коефіцієнт степеня 2, числа з рухомою комою розподіляють біти на три різні частини: <strong>індикатор знака</strong>, <span>\(s\)</span>, який вказує, чи є число додатним чи від'ємним; <strong>характеристику</strong> або <strong>експоненту</strong>, <span>\(e\)</span>, яка є степенем 2; і <strong>мантису</strong>, <span>\(f\)</span>, яка є коефіцієнтом експоненти. Майже всі платформи відображають числа з рухомою комою Python у формат <strong>IEEE 754</strong> подвійної точності — загалом 64 біти. 1 біт виділяється для індикатора знака, 11 бітів — для експоненти, і 52 біти — для мантиси. З 11 бітами, виділеними для експоненти, це дає 2048 значень, яких може набувати це число. Оскільки ми хочемо мати можливість представляти дуже точні числа, нам потрібно, щоб деякі з цих значень представляли від'ємні експоненти (тобто, дозволяли числа між 0 і 1 (у десятковій системі)). Для цього від експоненти віднімається 1023 для її нормалізації. Значення, що віднімається від експоненти, зазвичай називають <strong>зміщенням</strong>. Мантиса — це число між 1 і 2. У двійковій системі це означає, що старший розряд завжди буде 1, і, отже, зберігати його — це марна трата бітів. Для економії місця старша одиниця відкидається. У Python ми можемо отримати інформацію про числа з рухомою комою за допомогою пакета <em>sys</em>, як показано нижче:</p>


<pre><span></span><span>import</span> <span>sys</span>
<span>sys</span><span>.</span><span>float_info</span>
</pre>



<pre><span></span>sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)
</pre>



<p>Тоді число з рухомою комою можна представити як:</p>
<!---
$n = (-1)^s 2^{e-127} (1+f).$  (для 32-біт)
--->
<p><span>\(n = (-1)^s 2^{e-1023} (1+f).\)</span>  (для 64-біт)</p>
<p><strong>СПРОБУЙТЕ!</strong> Якому числу в десятковій системі відповідає 1 10000000010 1000000000000000000000000000000000000000000000000000 (IEEE 754)?</p>
<p>Експонента в десятковій системі дорівнює <span>\(1 \cdot   2^{10} + 1 \cdot   2^{1} - 1023 = 3\)</span>. Мантиса дорівнює <span>\(1 \cdot  \frac{1}{2^1} + 0 \cdot  \frac{1}{2^2} + ... = 0.5\)</span>. Отже <span>\(n = (-1)^1  \cdot   2^{3}  \cdot   (1 + 0.5) = -12.0\)</span> (у десятковій системі). Дивіться деталі на наступному малюнку.</p>
<p><img alt="двійкове представлення" src="https://raw.githubusercontent.com/dimabendera/python-ml-lessons/main/source/pythonnumericalmethods/_images/09.02.01-Binary_neg_12.png"/></p>
<p><strong>СПРОБУЙТЕ!</strong> Як виглядає число 15.0 (у десятковій системі) у форматі IEEE 754? Яке найбільше число, менше за 15.0? Яке найменше число, більше за 15.0?</p>
<p>Оскільки число додатне, <span>\(s = 0\)</span>. Найбільший степінь двійки, менший за 15.0, — це 8, тому експонента дорівнює 3, що робить характеристику <span>\(3 + 1023 = 1026 (у десятковій системі) = 10000000010(у двійковій системі)\)</span>. Тоді мантиса дорівнює <span>\(15/8-1=0.875(у десятковій системі) = 1\cdot \frac{1}{2^1} + 1\cdot \frac{1}{2^2} + 1\cdot \frac{1}{2^3}\)</span> = 1110000000000000000000000000000000000000000000000000 (у двійковій системі). Якщо скласти все разом, отримаємо наступне перетворення:
15 (у десятковій системі) = 0 10000000010 1110000000000000000000000000000000000000000000000000 (IEEE 754)</p>
<p>Наступне найменше число — це 0 10000000010 1101111111111111111111111111111111111111111111111111 = 14.9999999999999982236431605997</p>
<p>Наступне найбільше число — це 0 10000000010 1110000000000000000000000000000000000000000000000001 = 15.0000000000000017763568394003</p>
<p>Отже, число у форматі IEEE 754 0 10000000010 1110000000000000000000000000000000000000000000000000 представляє не тільки число 15.0, але й усі дійсні числа на півдорозі між його безпосередніми сусідами. Тому будь-яке обчислення, результат якого потрапляє в цей інтервал, отримає значення 15.0.</p>
<p>Відстань від одного числа до наступного ми називаємо <strong>проміжком</strong>. Оскільки мантиса множиться на <span>\(2^{e-1023}\)</span>, проміжок зростає зі збільшенням представленого числа. Проміжок для заданого числа можна обчислити за допомогою функції <em>spacing</em> у <em>numpy</em>.</p>


<pre><span></span><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
</pre>



<p><strong>СПРОБУЙТЕ!</strong> Використайте функцію <em>spacing</em>, щоб визначити проміжок для 1e9. Переконайтеся, що додавання до 1e9 числа, меншого за половину проміжку для 1e9, дає те саме число.</p>


<pre><span></span><span>np</span><span>.</span><span>spacing</span><span>(</span><span>1e9</span><span>)</span>
</pre>



<pre><span></span>1.1920928955078125e-07
</pre>





<pre><span></span><span>1e9</span> <span>==</span> <span>(</span><span>1e9</span> <span>+</span> <span>np</span><span>.</span><span>spacing</span><span>(</span><span>1e9</span><span>)</span><span>/</span><span>3</span><span>)</span>
</pre>



<pre><span></span>True
</pre>



<p>Існують спеціальні випадки для значень чисел з рухомою комою, коли e = 0 (тобто e = 00000000000 (у двійковій системі)) і коли e = 2047 (тобто e = 11111111111 (у двійковій системі)), які є зарезервованими. Коли експонента дорівнює 0, старша одиниця в мантисі приймає значення 0. Результатом є <strong>субнормальне число</strong>, яке обчислюється за формулою <span>\(n=(-1)^s2^{-1022}(0+f)\)</span> (зверніть увагу: -1022 замість -1023). Коли експонента дорівнює 2047, а f не дорівнює нулю, результатом є "Not a Number" (не число), що означає, що число не визначене. Коли експонента дорівнює 2047, f = 0 і s = 0, результатом є додатна нескінченність. Коли експонента дорівнює 2047, f = 0, а s = 1, результатом є від'ємна нескінченність.</p>
<p><strong>СПРОБУЙТЕ!</strong> Обчисліть десяткове значення для 0 11111111110 1111111111111111111111111111111111111111111111111111 (IEEE 754), найбільшого визначеного числа для 64 біт, і для 0 00000000001 000000000000000000000000000000000000000000000000000 (IEEE 754), найменшого. Зверніть увагу, що експонента відповідно дорівнює e = 2046 та e = 1, щоб відповідати раніше зазначеним правилам. Перевірте, що Python погоджується з цими обчисленнями, використовуючи <em>sys.float_info.max</em> та <em>sys.float_info.min</em>.</p>


<pre><span></span><span>largest</span> <span>=</span> <span>(</span><span>2</span><span>**</span><span>(</span><span>2046</span><span>-</span><span>1023</span><span>))</span><span>*</span><span>((</span><span>1</span> <span>+</span> <span>sum</span><span>(</span><span>0.5</span><span>**</span><span>np</span><span>.</span><span>arange</span><span>(</span><span>1</span><span>,</span> <span>53</span><span>))))</span>
<span>largest</span>
</pre>



<pre><span></span>1.7976931348623157e+308
</pre>





<pre><span></span><span>sys</span><span>.</span><span>float_info</span><span>.</span><span>max</span>
</pre>



<pre><span></span>1.7976931348623157e+308
</pre>





<pre><span></span><span>smallest</span> <span>=</span> <span>(</span><span>2</span><span>**</span><span>(</span><span>1</span><span>-</span><span>1023</span><span>))</span><span>*</span><span>(</span><span>1</span><span>+</span><span>0</span><span>)</span>
<span>smallest</span>
</pre>



<pre><span></span>2.2250738585072014e-308
</pre>





<pre><span></span><span>sys</span><span>.</span><span>float_info</span><span>.</span><span>min</span>
</pre>



<pre><span></span>2.2250738585072014e-308
</pre>



<p>Числа, більші за найбільше представлюване число з рухомою комою, призводять до <strong>переповнення</strong>, і Python обробляє цей випадок, присвоюючи результату значення <em>inf</em>. Числа, менші за найменше субнормальне число, призводять до <strong>втрати значущості</strong>, і Python обробляє цей випадок, присвоюючи результату значення 0.</p>
<p><strong>СПРОБУЙТЕ!</strong> Покажіть, що додавання 2 до максимального 64-бітного числа з рухомою комою дає те саме число. Число з рухомою комою в Python не має достатньої точності, щоб зберегти +2 для sys.float_info.max, тому операція по суті еквівалентна додаванню нуля. Також покажіть, що додавання максимального 64-бітного числа з рухомою комою до самого себе призводить до переповнення, і що Python присвоює цьому числу значення <em>inf</em>.</p>


<pre><span></span><span>sys</span><span>.</span><span>float_info</span><span>.</span><span>max</span> <span>+</span> <span>2</span> <span>==</span> <span>sys</span><span>.</span><span>float_info</span><span>.</span><span>max</span>
</pre>



<pre><span></span>True
</pre>





<pre><span></span><span>sys</span><span>.</span><span>float_info</span><span>.</span><span>max</span> <span>+</span> <span>sys</span><span>.</span><span>float_info</span><span>.</span><span>max</span>
</pre>



<pre><span></span>inf
</pre>



<p><strong>СПРОБУЙТЕ!</strong> Найменше субнормальне 64-бітне число має s = 0, e = 00000000000, і f = 0000000000000000000000000000000000000000000000000001. Використовуючи спеціальні правила для субнормальних чисел, це дає субнормальне число <span>\((-1)^02^{1-1023}2^{-52} = 2^{-1074}\)</span>. Покажіть, що <span>\(2^{-1075}\)</span> призводить до втрати значущості до 0.0, і що результат неможливо відрізнити від 0.0. Покажіть, що <span>\(2^{-1074}\)</span> — ні.</p>


<pre><span></span><span>2</span><span>**</span><span>(</span><span>-</span><span>1075</span><span>)</span>
</pre>



<pre><span></span>0.0
</pre>





<pre><span></span><span>2</span><span>**</span><span>(</span><span>-</span><span>1075</span><span>)</span> <span>==</span> <span>0</span>
</pre>



<pre><span></span>True
</pre>





<pre><span></span><span>2</span><span>**</span><span>(</span><span>-</span><span>1074</span><span>)</span>
</pre>



<pre><span></span>5e-324
</pre>



<p>Отже, що ми виграли, використовуючи IEEE 754 замість двійкового представлення? Використання 64-бітного двійкового представлення дає нам <span>\(2^{64}\)</span> чисел. Оскільки кількість бітів не змінюється між двійковим представленням та IEEE 754, IEEE 754 також повинен давати нам <span>\(2^{64}\)</span> чисел. У двійковому представленні числа мають постійний проміжок між собою. В результаті, ви не можете мати одночасно і діапазон (тобто велику відстань між мінімальним і максимальним представлюваними числами), і точність (тобто малий проміжок між числами). Контроль цих параметрів залежав би від того, де ви поставите десяткову кому у вашому числі. IEEE 754 долає це обмеження, використовуючи дуже високу точність для малих чисел і дуже низьку точність для великих чисел. Це обмеження зазвичай є прийнятним, оскільки проміжок для великих чисел все ще малий відносно розміру самого числа. Тому, навіть якщо проміжок становить мільйони, це не має значення для звичайних обчислень, якщо число, що розглядається, знаходиться в трильйонах або вище.</p>
```
