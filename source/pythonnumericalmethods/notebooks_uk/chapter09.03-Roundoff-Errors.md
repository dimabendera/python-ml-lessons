```html
<h1>Похибки округлення<a href="#round-off-errors" title="Permalink to this headline"></a></h1>
<p>У попередньому розділі ми говорили про те, як числа з рухомою комою представлені в комп'ютерах у вигляді двійкових дробів. Це має побічний ефект, що числа з рухомою комою не можуть зберігатися з ідеальною точністю, натомість вони апроксимуються скінченною кількістю байтів. Тому різниця між наближенням числа, що використовується в обчисленнях, та його правильним (істинним) значенням називається <strong>похибкою округлення</strong>. Це одна з поширених похибок, що зазвичай виникають у числових розрахунках. Інша — це <strong>похибка усічення</strong>, яку ми розглянемо в <span>Розділі 18</span>. Різниця полягає в тому, що похибка усічення — це похибка, що виникає через усічення нескінченної суми та її наближення скінченною сумою.</p>

<h2>Похибка представлення<a href="#representation-error" title="Permalink to this headline"></a></h2>
<p>Найпоширенішою формою похибки округлення є похибка представлення чисел з рухомою комою. Простим прикладом буде представлення <span>\(\pi\)</span>. Ми знаємо, що <span>\(\pi\)</span> — це нескінченне число, але коли ми його використовуємо, ми зазвичай беремо лише скінченну кількість цифр. Наприклад, якщо ви використовуєте лише 3.14159265, виникне похибка між цим наближенням та істинним нескінченним числом. Іншим прикладом буде 1/3, істинне значення якого 0.333333333…, і незалежно від того, скільки десяткових знаків ми виберемо, похибка округлення все одно буде.</p>
<p>Крім того, коли ми округлюємо числа кілька разів, похибка буде накопичуватися. Наприклад, якщо 4.845 округлити до двох десяткових знаків, вийде 4.85. Якщо потім округлити його ще раз до одного десяткового знака, вийде 4.9, і загальна похибка складе 0.55. Але якщо ми округлимо лише один раз до одного десяткового знака, вийде 4.8, і похибка складе 0.045.</p>


<h2>Похибка округлення в арифметиці з рухомою комою<a href="#round-off-error-by-floating-point-arithmetic" title="Permalink to this headline"></a></h2>
<p>З попереднього прикладу, похибка між 4.845 та 4.8 мала б бути 0.055. Але якщо ви обчислите це в Python, ви побачите, що 4.9 - 4.845 не дорівнює 0.055.</p>


<pre><span></span><span>4.9</span> <span>-</span> <span>4.845</span> <span>==</span> <span>0.055</span>
</pre>



<pre><span></span>False
</pre>



<p>Чому так відбувається? Якщо ми подивимося на результат 4.9 - 4.845, ми побачимо, що насправді отримуємо 0.055000000000000604. Це тому, що число з рухомою комою не може бути представлене точним значенням, це лише наближення, і коли воно використовується в арифметичних операціях, це викликає невелику похибку.</p>


<pre><span></span><span>4.9</span> <span>-</span> <span>4.845</span>
</pre>



<pre><span></span>0.055000000000000604
</pre>





<pre><span></span><span>4.8</span> <span>-</span> <span>4.845</span>
</pre>



<pre><span></span>-0.04499999999999993
</pre>



<p>Інший приклад нижче показує, що 0.1 + 0.2 + 0.3 не дорівнює 0.6, що має ту ж саму причину.</p>


<pre><span></span><span>0.1</span> <span>+</span> <span>0.2</span> <span>+</span> <span>0.3</span> <span>==</span> <span>0.6</span>
</pre>



<pre><span></span>False
</pre>



<p>Хоча числа неможливо зробити ближчими до їхніх очікуваних точних значень, функція <em>round</em> може бути корисною для заокруглення результату, щоб значення з неточностями можна було порівнювати між собою:</p>


<pre><span></span><span>round</span><span>(</span><span>0.1</span> <span>+</span> <span>0.2</span> <span>+</span> <span>0.3</span><span>,</span> <span>5</span><span>)</span>  <span>==</span> <span>round</span><span>(</span><span>0.6</span><span>,</span> <span>5</span><span>)</span>
</pre>



<pre><span></span>True
</pre>





<h2>Накопичення похибки округлення<a href="#accumulation-of-round-off-error" title="Permalink to this headline"></a></h2>
<p>Коли ми виконуємо послідовність обчислень над початковими даними, що мають похибку округлення через неточне представлення, похибки можуть збільшуватися або накопичуватися. Нижче наведено приклад, де ми до числа 1 додаємо і віднімаємо 1/3, що дає нам те ж саме число 1. Але що, якщо ми багато разів додамо 1/3 і стільки ж разів віднімемо 1/3, чи отримаємо ми все ще те саме число 1? Ні, як видно з прикладу нижче, чим більше разів ви це робите, тим більше похибок ви накопичуєте.</p>


<pre><span></span><span># Якщо ми робимо це лише один раз</span>
<span>1</span> <span>+</span> <span>1</span><span>/</span><span>3</span> <span>-</span> <span>1</span><span>/</span><span>3</span>
</pre>



<pre><span></span>1.0
</pre>





<pre><span></span><span>def</span> <span>add_and_subtract</span><span>(</span><span>iterations</span><span>):</span>
    <span>result</span> <span>=</span> <span>1</span>
    
    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>iterations</span><span>):</span>
        <span>result</span> <span>+=</span> <span>1</span><span>/</span><span>3</span>

    <span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>iterations</span><span>):</span>
        <span>result</span> <span>-=</span> <span>1</span><span>/</span><span>3</span>
    <span>return</span> <span>result</span>
</pre>





<pre><span></span><span># Якщо ми робимо це 100 разів</span>
<span>add_and_subtract</span><span>(</span><span>100</span><span>)</span>
</pre>



<pre><span></span>1.0000000000000002
</pre>





<pre><span></span><span># Якщо ми робимо це 1000 разів</span>
<span>add_and_subtract</span><span>(</span><span>1000</span><span>)</span>
</pre>



<pre><span></span>1.0000000000000064
</pre>





<pre><span></span><span># Якщо ми робимо це 10000 разів</span>
<span>add_and_subtract</span><span>(</span><span>10000</span><span>)</span>
</pre>



<pre><span></span>1.0000000000001166
</pre>
```
