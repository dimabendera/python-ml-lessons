<h1>Обговорення помилок<a href="#discussion-on-errors" title="Постійне посилання на цей заголовок"></a></h1>

<h2>Помилки усікання для ряду Тейлора<a href="#truncation-errors-for-taylor-series" title="Постійне посилання на цей заголовок"></a></h2>
<p>При проведенні чисельного аналізу зазвичай існують два джерела помилок: помилки <strong>округлення</strong> та помилки <strong>усікання</strong>. Помилки округлення виникають через неточність представлення дійсних чисел на комп'ютері та арифметичних операцій, що виконуються з ними. У той час як помилки усікання зумовлені наближеним характером використовуваного методу, вони зазвичай виникають через використання апроксимації замість точної математичної процедури, наприклад, коли ми використовуємо ряд Тейлора для апроксимації функції. Наприклад, ми можемо використовувати ряд Тейлора для апроксимації функції <span>\(e^x\)</span>:</p>

\[e^x = 1+x+\frac{x^2}{2!} + \frac{x^3}{3!} + \frac{x^4}{4!} + \dots\]
<p>Оскільки для апроксимації функції потрібна нескінченна послідовність, якщо ми візьмемо лише кілька членів, ми отримаємо помилку усікання. Наприклад, якщо ми використаємо лише перші 4 члени для апроксимації <span>\(e^2\)</span>, це буде:</p>

\[ \begin{align}\begin{aligned}e^2 \approx 1+2+\frac{2^2}{2!} + \frac{2^3}{3!} = 6.3333$$, \\Ми бачимо, що з цим пов'язана помилка, оскільки ми усікаємо решту членів ряду Тейлора. Отже, функцію $f(x)$ можна записати як апроксимацію ряду Тейлора плюс член помилки усікання:\\$$f(x) = f_n(x) + E_n(x)\end{aligned}\end{align} \]
<p>Чим більше членів ми використовуємо, тим ближчою буде апроксимація до точного значення. Давайте використаємо Python, щоб розглянути наведений вище приклад.</p>
<p><strong>СПРОБУЙТЕ!</strong> Апроксимуйте <span>\(e^2\)</span>, використовуючи різні порядки ряду Тейлора, та виведіть результати.</p>


<pre><span></span><span>import</span> <span>numpy</span> <span>as</span> <span>np</span>
</pre>





<pre><span></span><span>exp</span> <span>=</span> <span>0</span>
<span>x</span> <span>=</span> <span>2</span>
<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>10</span><span>):</span>
    <span>exp</span> <span>=</span> <span>exp</span> <span>+</span> \
       <span>((</span><span>x</span><span>**</span><span>i</span><span>)</span><span>/</span><span>np</span><span>.</span><span>math</span><span>.</span><span>factorial</span><span>(</span><span>i</span><span>))</span>
    <span>print</span><span>(</span><span>f</span><span>'Using </span><span>{</span><span>i</span><span>}</span><span>-term, </span><span>{</span><span>exp</span><span>}</span><span>'</span><span>)</span>
    
<span>print</span><span>(</span><span>f</span><span>'The true e^2 is: </span><span>\n</span><span>{</span><span>np</span><span>.</span><span>exp</span><span>(</span><span>2</span><span>)</span><span>}</span><span>'</span><span>)</span>
</pre>



<pre><span></span>Using 0-term, 1.0
Using 1-term, 3.0
Using 2-term, 5.0
Using 3-term, 6.333333333333333
Using 4-term, 7.0
Using 5-term, 7.266666666666667
Using 6-term, 7.355555555555555
Using 7-term, 7.3809523809523805
Using 8-term, 7.387301587301587
Using 9-term, 7.3887125220458545
The true e^2 is: 
7.38905609893065
</pre>





<h2>Оцінка помилок усікання<a href="#estimate-truncation-errors" title="Постійне посилання на цей заголовок"></a></h2>
<p>Ми бачимо, що чим вищий порядок ми використовуємо для апроксимації функції в заданому значенні, тим ближче ми до істинного значення. Для кожного обраного порядку існує пов'язана з ним помилка, і апроксимація є корисною лише тоді, коли ми маємо уявлення про її точність. Це є мотивацією для глибшого розуміння помилок.</p>
<p>З ряду Тейлора, якщо ми використовуємо лише перші <span>\(n\)</span> членів, ми бачимо:</p>

\[ f(x) = f_n(x) + E_n(x) = \sum_{k = 0}^{n} \frac{f^{(k)}(a)(x-a)^k}{k!} + E_n(x)
\]
<p><span>\(E_n(x)\)</span> — це залишок ряду Тейлора, або помилка усікання, яка вимірює, наскільки апроксимація <span>\(f_n(x)\)</span> відрізняється від <span>\(f(x)\)</span>. Ми можемо оцінити помилку, використовуючи <strong>Теорему про оцінку залишку Тейлора</strong>, яка стверджує:</p>
<p>Якщо функція <span>\(f(x)\)</span> має <span>\(n+1\)</span> похідних для всіх <span>\(x\)</span> в інтервалі <span>\(I\)</span>, що містить <span>\(a\)</span>, то для кожного x в <span>\(I\)</span> існує <span>\(z\)</span> між <span>\(x\)</span> та <span>\(a\)</span> таке, що</p>

\[ E_n(x) = \frac{f^{(n+1)}(z)(x-a)^{(n+1)}}{(n+1)!}
\]
<p>У багатьох випадках, якщо ми знаємо, що <span>\(M\)</span> є максимальним значенням <span>\(|f^{(n+1)}|\)</span> в інтервалі, ми отримаємо:</p>

\[ |E_n(x)| \le \frac{M|x-a|^{(n+1)}}{(n+1)!}
\]
<p>Отже, ми можемо отримати межу для помилки усікання, використовуючи цю теорему. Давайте розглянемо приклад.</p>
<p><strong>СПРОБУЙТЕ!</strong> Оцініть межу залишку для апроксимації за допомогою ряду Тейлора для <span>\(e^2\)</span>, використовуючи n = 9.</p>
<p>Давайте попрацюємо над помилкою, коли ми використовуємо n = 9. Ми знаємо, що <span>\((e^x)' = e^x\)</span>, і a = 0. Отже, помилка, пов'язана з x = 2, становить:</p>

\[ E_n(x) = \frac{f^{(9+1)}(z)(x)^{(9+1)}}{(9+1)!} = \frac{e^{z}2^{10}}{10!}
\]
<p>Нагадаємо, що <span>\( 0 \le z \le 2\)</span>, і <span>\(e &lt; 3\)</span>, ми отримаємо</p>

\[ |E_n(x)| \le \frac{3^{2}2^{10}}{10!} = 0.00254
\]
<p>Отже, якщо ми використовуємо ряд Тейлора з n = 9 для апроксимації <span>\(e^2\)</span>, наша абсолютна помилка повинна бути меншою за 0.00254. Давайте також перевіримо це нижче.</p>


<pre><span></span><span>abs</span><span>(</span><span>7.3887125220458545</span><span>-</span><span>np</span><span>.</span><span>exp</span><span>(</span><span>2</span><span>))</span>
</pre>



<pre><span></span>0.0003435768847959153
</pre>





<h2>Помилки округлення для ряду Тейлора<a href="#round-off-errors-for-taylor-series" title="Постійне посилання на цей заголовок"></a></h2>
<p>Чисельно, при додаванні багатьох членів у сумі, ми повинні пам'ятати про чисельне накопичення помилок, що виникають через помилки округлення з плаваючою комою. Розглянемо наступний приклад.</p>
<p><strong>ПРИКЛАД:</strong> Апроксимуйте <span>\(e^{-30}\)</span>, використовуючи різні порядки ряду Тейлора, та виведіть результати.</p>


<pre><span></span><span>exp</span> <span>=</span> <span>0</span>
<span>x</span> <span>=</span> <span>-</span><span>30</span>
<span>for</span> <span>i</span> <span>in</span> <span>range</span><span>(</span><span>200</span><span>):</span>
    <span>exp</span> <span>=</span> <span>exp</span> <span>+</span> \
       <span>((</span><span>x</span><span>**</span><span>i</span><span>)</span><span>/</span><span>np</span><span>.</span><span>math</span><span>.</span><span>factorial</span><span>(</span><span>i</span><span>))</span>
    
<span>print</span><span>(</span><span>f</span><span>'Using </span><span>{</span><span>i</span><span>}</span><span>-term, our result is </span><span>{</span><span>exp</span><span>}</span><span>'</span><span>)</span>    
<span>print</span><span>(</span><span>f</span><span>'The true e^2 is: </span><span>{</span><span>np</span><span>.</span><span>exp</span><span>(</span><span>x</span><span>)</span><span>}</span><span>'</span><span>)</span>
</pre>



<pre><span></span>Using 199-term, our result is -8.553016433669241e-05
The true e^2 is: 9.357622968840175e-14
</pre>



<p>З наведеного вище прикладу зрозуміло, що наша оцінка за допомогою ряду Тейлора більше не є близькою до істинного значення, незалежно від того, скільки членів ви включите в розрахунок. Це пов'язано з помилками округлення, які ми обговорювали раніше. При використанні великих від'ємних аргументів, щоб отримати малий результат, ряд Тейлора потребує чергування великих чисел, які взаємно скорочуються для досягнення цього. Нам потрібно багато знаків точності в ряді, щоб захопити як великі, так і малі числа з достатньою кількістю залишкових знаків для отримання результату з бажаною вихідною точністю. Таким чином, ми маємо цю помилку в наведеному вище прикладі.</p>
